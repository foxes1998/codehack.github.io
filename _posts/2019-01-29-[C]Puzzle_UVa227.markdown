---
layout: post
title:  "[C]Puzzle_UVa227"
date:   2019-01-29 19:00:00 +0800
categories:	[UVa]
tags:	[UVa, UVa227 ,Puzzle]
---
此题来自 UVa(UVa Online Judge, 西班牙Valladolid大学的Online Judge。是最古老也是全世界最知名的Online Judge)，题号为 UVa227 ，同时也是*刘汝佳*大佬在《算法入门》所给的第三章练习题之一。

[原题目链接(英文)][原题目链接(英文)]

[题目原文档(英文)][题目原文档(英文)]
### 题目描述(中文翻译)：
> 30年前流行的儿童拼图游戏由一个5×5的框架组成的，其中包含24个相同大小的小方块。 每个小正方形上都印有一个独特的字母。 由于框架内只有24个正方形，因此框架还包含一个与小正方形大小相同的空位置。 如果正方形位于空位置的右侧，左侧，上方或下方，则可将方形移动到该空位置。 拼图的目的是将方块滑动到空位置，以便框架按字母顺序显示字母。

> 例图显示了一个拼图的原始布局和在以下6个移动顺序之后的布局：
>
>> 1) 空格上方的方块移动
>
>> 2) 空格右侧的方块移动
>
>> 3) 空格右侧的方块移动
>
>> 4) 空格下方的方块移动
>
>> 5) 空格下方的方块移动
>
>> 6) 空格左侧的方块移动
>
> ![示例图片]({{ site.baseurl }}/includes/UVa/201-300/example.png)

> 编写一个程序来显示给定初始布局和移动顺序的结果帧。

### 输入规则
> 程序的输入由几个拼图题组成。每一个都是由它的初始布局和在拼图上的移动顺序来描述的。每个拼图描述的前5行是初始布局。后面的几行给出了移动的顺序。
>
>  帧显示的第一行与拼图中的方格顶行相对应。其他行按顺序排列。框架中的空位置用空格表示。每一显示行正好包含5个字符，从最左边的方块上的字符开始（如果最左边的方块实际上是空的帧位置，则为空白）。显示行将对应于合法的拼图。
>
>  移动顺序由一系列的 A 、B 、R 和 L 表示，以表示哪个方块移动到空位置。A 表示空位上方的方块移动；B 表示空位下方的方块移动；L 表示空位左侧的方块移动；R 表示空位右侧的方块移动。可能存在非法移动，即使它由4个移动字符之一表示。如果发生了非法移动，则认为拼图没有最终布局。这一移动顺序可以分布在多行上，但始终以数字0结尾。数据的结尾由字符Z表示。

### 输出规则
> 每个拼图的输出从一个适当标记的数字开始（Puzzle #1、Puzzle #2等）。如果拼图没有最终的布局，那么应该在其后输出一条这样的提示信息。否则，应显示最终布局。
>
>  为最终布局的输出格式化每行以便阅读，使在两个相邻字母之间有一个空白字符。把空正方形当作字母。例如，如果空白是一个内部位置，那么它将出现为3个空白序列-一个将它与左边正方形分隔，一个用于空位置本身，一个将它与右边正方形分离。
>
>  用一个空行将不同拼图记录的输出分开。
>
> __注__ ：样本输入的第一个记录对应于上面所示的拼图。

### 输入示例
<pre>
TRGSJ
XDOKI
M VLN
WPABE
UQHCF
ARRBBL0
ABCDE
FGHIJ
KLMNO
PQRS 
TUVWX
AAA
LLLL0
ABCDE
FGHIJ
KLMNO
PQRS 
TUVWX
AAAAABBRRRLL0
Z
</pre>

### 示例输出
<pre>
Puzzle #1: 
T R G S J
X O K L I
M D V B N
W P   A E
U Q H C F

Puzzle #2:
  A B C D
F G H I E
K L M N J
P Q R S O
T U V W X

Puzzle #3:
This puzzle has no final configuration.
</pre>


{% highlight c linenos %}
#include<stdio.h>
#include<string.h>
#define maxn1 100
#define maxn2 10000+10

int mv_Puzzle(char a[5][5],char *b){
    int t=0,x,y,flag2=1;
    for(x=0  ;x<5 && flag2  ;x++){
        for(y=0  ;y<5 && flag2  ;y++){
            if(a[x][y] == ' ')
                flag2=0;
        }
    }
    flag2=1;
    x--;
    y--;
    // printf("x=%d ,y=%d ,s[x][y]=\'%c\'\n",x,y,a[x][y]);
    while(b[t]!='0'&&flag2){
        if(b[t]=='A'||b[t]=='B'||b[t]=='L'||b[t]=='R'){
            if(b[t]=='A'){
                if(x-1<0){
                    flag2=0;
                }else{
                    a[x][y] = a[x-1][y];
                    a[x-1][y] = ' ';
                    x--;
                }
            }
            if(b[t]=='B'){
                if(x+1>5){
                    flag2=0;
                }else{
                    a[x][y] = a[x+1][y];
                    a[x+1][y] = ' ';
                    x++;
                }
            }
            if(b[t]=='L'){
                if(y-1<0){
                    flag2=0;
                }else{
                    a[x][y] = a[x][y-1];
                    a[x][y-1] = ' ';
                    y--;
                }
            }
            if(b[t]=='R'){
                if(y+1>5){
                    flag2=0;
                }else{
                    a[x][y] = a[1][y+1];
                    a[x][y+1] = ' ';
                    y++;
                }
            }
            t++;
        } else
        {
            flag2=0;
        }
        
    }
    return flag2;
}
void Print_Puzzle(char a[5][5]){
    for(int i=0;i<5;i++){
        for(int j=0;j<5;j++){
            if(j<4){
                printf("%c ",a[i][j]);
            } else
                printf("%c\n",a[i][j]);
        }
    }
}
void Puzzle(){
    int flag1=1,kase=0,m=0,p=0;
    char s[maxn2];
    while(1){
        char tmp[maxn1];
        scanf("%[^\n]%*c",tmp);
        int len=strlen(tmp);
        memcpy(&s[m],tmp,len);
        m=m+len;
        if(s[m-1]=='Z') 
            break;
    }
    // printf("%s\n\n",s);
    while(flag1){
        char a[5][5]={'\0'},b[maxn1]={'\0'};
        for(int i=0;i<5&&flag1;i++){
            for(int j=0;j<5&&flag1;j++){
                a[i][j]=s[p++];
                if(a[0][0]=='Z'){
                    flag1 = 0;
                }
            }
        }
        if(!flag1)   break;
        int t=-1;
        do
        {
            b[++t]=s[p++];
        } while (b[t]!='0');
        // printf("\n%s\n\n",b);
        if(kase) 
            printf("\n");
        printf("Puzzle #%d:\n",++kase);
        if(mv_Puzzle(a,b)){
            Print_Puzzle(a);
        } else 
            printf("This puzzle has no final configuration.\n");
    }
}

int main(){
    Puzzle();
    // char s[maxn1];
    // scanf("%[^\n]",s); //读取单行，应该等价于 gets(); 
    //据说 ansi c 里面没有 gets();或者是算法竞赛不允许用
    // printf("%s\n",s);
    return 0;
}
{% endhighlight %}

每文一言：
<figure>
	<img src="{{ site.baseurl }}/assets/space.jpg" alt="image">
	<figcaption>
		Don't aim for success if you want it; just do what you love and believe in, and it will come naturally.<br/>
		如果你想要成功，不要去追求成功；尽管做你自己热爱的事情并且相信它，成功自然到来。
	</figcaption>
</figure>


* * *
* * *
<br/>
* * *
更新于2019-02-02 23:20
* * *
添加上了我自己的代码，预计明日会加上比较完整的思路解析
<br/>
* * *
* * *

如有问题可在底部通过邮箱联系我。

<a href="mailto:feather@codehack.life?subject=[re]{{page.title}}&body=Article_url:  {{ site.url }}{{ page.url }} ">feather@codehack.life</a>

[原题目链接(英文)]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=4&page=show_problem&problem=163
[题目原文档(英文)]: {{ site.baseurl }}/includes/UVa/201-300/UVa227.pdf